# -*- coding: utf-8 -*-
"""MaskRCNN_IoU_Calculation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SMonjL_exHcwAGX-AeTvBAE6uMYYwPPc
"""

from google.colab import drive
drive.mount('/content/drive')

import warnings
warnings.filterwarnings('ignore')
import os
import sys
import json
import datetime
import numpy as np
import skimage.draw
import cv2
import random
import math
import re
import time
import tensorflow as tf
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.image as mpimg
import skimage.io

# Commented out IPython magic to ensure Python compatibility.
ROOT_DIR = '/content/drive/MyDrive/measure_maskrcnn/'
# %cd /content/drive/MyDrive/testing_maskrcnn/

IMG_DIR = "/content/drive/MyDrive/measure_maskrcnn/img/"
MASK_DIR = "/content/drive/MyDrive/measure_maskrcnn/mask/"

WEIGHTS_PATH = ROOT_DIR + "4/mask_rcnn_object_0050.h5"

!pip install -r '/content/drive/MyDrive/measure_maskrcnn/requirements.txt'

!python3 setup.py install

sys.path.append(ROOT_DIR)

from mrcnn import utils
import mrcnn.model as modellib
from mrcnn.model import log
from mrcnn.config import Config
from mrcnn import model as modellib, utils

for x in range(len(os.listdir(IMG_DIR))):
  if os.listdir(IMG_DIR)[x] not in os.listdir(MASK_DIR):
    print("img:")
    print(os.listdir(IMG_DIR)[x])
  
  if os.listdir(MASK_DIR)[x] not in  os.listdir(IMG_DIR):
    print("mask:")
    print(os.listdir(MASK_DIR)[x])

print(len(os.listdir(IMG_DIR)), "instances available.")

class CustomConfig(Config):
    # Derives from the base Config class and overrides some values.
    NAME = "object"
    GPU_COUNT = 1
    IMAGES_PER_GPU = 2
    NUM_CLASSES = 3
    STEPS_PER_EPOCH = 100
    DETECTION_MIN_CONFIDENCE = 0.8
    VALIDATION_STEPS = 10

config = CustomConfig()
class InferenceConfig(config.__class__):
    # Run detection on one image at a time
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1
    DETECTION_MIN_CONFIDENCE = 0.8

config = InferenceConfig()
#config.display()

#config = CustomConfig()

#Create model in inference mode
model = modellib.MaskRCNN(mode="inference", model_dir=ROOT_DIR, config=config)

# Load weights
print("Loading weights ", WEIGHTS_PATH)
model.load_weights(WEIGHTS_PATH, by_name=True)

iou_scores = []
instance_count = len(os.listdir("/content/drive/MyDrive/measure_maskrcnn/img"))
count = 0

for img_name in os.listdir(IMG_DIR):
  count+=1
  print("%%%%%%%%%%%%%%%", count, "/", instance_count, "Processing:", img_name, "%%%%%%%%%%%%%%%")

  image_path = IMG_DIR + img_name
  test_image = skimage.io.imread(image_path)

  # Fitting the image into processable form by Mask R-CNN Network
  if test_image.ndim != 3:
    test_image = skimage.color.gray2rgb(image1)
  # Remove alpha channel for consistency, if it has one
  if test_image.shape[-1] == 4:
    test_image = test_image[..., :3]  

  results = model.detect([test_image], verbose=1) # Returns the class prediction, mask and the box
  results = results[0]    

  # Getting the mask image provided for the test image
  path_to_mask = MASK_DIR + img_name
  mask = skimage.io.imread(path_to_mask)

  # Extracting mask pixels in bool manner
  mask_extracted = []
  for x in mask:
    line = []
    for y in x:
      if y.any() != 0:
        line.append([True])
      else:
        line.append([False])
    mask_extracted.append(line)
  mask_extracted = np.array(mask_extracted)

  # Prediction results include prediction mask data.
  # Forming this data into the same way as we have.
  extracted_pred_mask = []
  for x in results['masks']:
    line = []
    for y in x:
      if y.any() != 0:
        line.append([True])
      else:
        line.append([False])
    extracted_pred_mask.append(line)
  extracted_pred_mask = np.array(extracted_pred_mask)

  # IoU Score
  score = utils.compute_overlaps_masks(mask_extracted, extracted_pred_mask)[0][0]
  print("IoU:", score)
  iou_scores.append(score)

print(iou_scores[:10])
#print("Sum:", sum(iou_scores))
print("Avg:", sum(iou_scores) / instance_count)
print("Max:", max(iou_scores))